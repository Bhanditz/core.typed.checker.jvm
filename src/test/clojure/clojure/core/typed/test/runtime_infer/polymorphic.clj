(ns clojure.core.typed.test.runtime-infer.polymorphic
  {:lang :core.typed
   :core.typed {:features #{:runtime-infer}}
   }
  (:refer-clojure :exclude [identity memoize])
  (:require [clojure.core.typed :as t]
            [clojure.core :as core]
            [clojure.spec.alpha :as s]
            [clojure.pprint :refer [pprint]]))

;; Start: Generated by clojure.core.typed - DO NOT EDIT
(s/def
  :clojure.core.typed.unqualified-keys64477/a
  (s/or :symbol? symbol? :int? int?))
(comment
  "Existing spec:"
  (s/def
    ::AMap
    (s/and
      (clojure.spec.alpha/keys
        :req-un
        [:clojure.core.typed.unqualified-keys62467/a]))))
(s/def
  ::AMap
  (s/keys :req-un [:clojure.core.typed.unqualified-keys64477/a]))
(comment
  "Existing spec:"
  (s/fdef
    get-a
    :args
    (clojure.spec.alpha/cat
      :m
      (clojure.spec.alpha/or
        :empty-map
        (clojure.spec.alpha/and clojure.core/map? clojure.core/empty?)
        :AMap
        ::AMap))
    :ret
    (clojure.spec.alpha/or
      :symbol?
      clojure.core/symbol?
      :int?
      clojure.core/int?
      :nil?
      clojure.core/nil?)
    :fn
    nil))
(s/fdef
  get-a
  :args
  (s/cat :m (s/or :empty-map (s/and map? empty?) :AMap ::AMap))
  :ret
  (s/or :symbol? symbol? :int? int? :nil? nil?))
(comment "Existing spec:" (s/def identity clojure.core/ifn?))
(s/fdef identity :args (s/cat :x int?) :ret int?)
(comment
  "Existing spec:"
  (s/fdef
    mymap
    :args
    (clojure.spec.alpha/cat
      :f
      clojure.core/ifn?
      :c
      (clojure.spec.alpha/coll-of
        (clojure.spec.alpha/or
          :symbol?
          clojure.core/symbol?
          :int?
          clojure.core/int?)
        :into
        clojure.core/vector?))
    :ret
    (clojure.spec.alpha/coll-of
      (clojure.spec.alpha/or
        :int?
        clojure.core/int?
        :string?
        clojure.core/string?))
    :fn
    nil))
(s/fdef
  mymap
  :args
  (s/cat
    :f
    ifn?
    :c
    (s/coll-of (s/or :symbol? symbol? :int? int?) :into vector?))
  :ret
  (s/coll-of (s/or :int? int? :string? string?)))
(comment
  "Existing spec:"
  (s/fdef
    plus1
    :args
    (clojure.spec.alpha/cat :x clojure.core/int?)
    :ret
    clojure.core/int?
    :fn
    nil))
(s/fdef plus1 :args (s/cat :x int?) :ret int?)
;; End: Generated by clojure.core.typed - DO NOT EDIT
(s/def identity ifn?)

(defn identity [x]
  x)

(defn plus1 [x]
  (inc x))

(defn memoize [f]
  (fn [a]
    (f a)))

(defn mymap [f c]
  (map f c))

(defn get-a [m]
  (:a m))

(identity 1)
;(identity 'a)
;(identity :a)

;(memoize identity)
;((memoize identity) 1)
;(identity 1)
;(identity 2)

;((memoize plus1) 1)

(mymap plus1 [1])
(mymap name ['a 'b 'c])

(get-a {:a 1})
(get-a {:a 'a})
(get-a {})
(get-a {})

;
;((memoize identity) 'a)
;((nth (iterate memoize identity) 100) :a)